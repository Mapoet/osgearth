/* -*-c++-*- */
/* osgEarth - Geospatial SDK for OpenSceneGraph
* Copyright 2020 Pelican Mapping
* http://osgearth.org
*
* osgEarth is free software; you can redistribute it and/or modify
* it under the terms of the GNU Lesser General Public License as published by
* the Free Software Foundation; either version 2 of the License, or
* (at your option) any later version.
*
* This program is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU Lesser General Public License for more details.
*
* You should have received a copy of the GNU Lesser General Public License
* along with this program.  If not, see <http://www.gnu.org/licenses/>
*/
#pragma once

#include <osgEarthProcedural/Biome>
#include <osg/BoundingBox>

namespace osgEarth
{
    namespace Procedural
    {
        using namespace osgEarth;

        /**
         * Manages the collection of active Biomes and Assets.
         * This class is responsible for making assets resident when
         * a containing Biome becomes active, and loading and creating
         * all the associated geometry and impostor geometry. It will
         * also unload these resident assets when they are no longer
         * needed.
         */
        class OSGEARTHPROCEDURAL_EXPORT BiomeManager
        {
        public:
            struct ResidentBiome
            {
                const Biome* biome;
                ResidentModelAssetInstances instances;
            };
            
            using ResidentBiomesById = std::map<
                std::string, // biome id
                ResidentBiome>;

        public:
            BiomeManager();

            void setAssetManager(ModelAssetManager::Ptr value) {
                _assetManager = value;
            }

            ModelAssetManager& getAssetManager() const {
                return *_assetManager;
            }

            //! The revision of the current configuration. This increments
            //! every time the set of resident biomes changes, so that a
            //! client can decide to get an updated configuration.
            int getRevision() const;

            //! Collection of all active biomes
            std::vector<const Biome*> getActiveBiomes() const;

            //! Gets a copy of the currently resident biomes
            //! (which is a snapshot in time)
            ResidentBiomesById getResidentBiomes(const osgDB::Options*);

        public: // internal system functions

            //! Tell the manager to increase the usage count of a biome by one.
            //! If there are no users, the manager will make the biome resident.
            //! @param biome Biome to activate
            void ref(const Biome* biome);

            //! Tell the manager to decrease the usage count of a biome by one.
            //! If the user count goes to zero, teh manager will release the
            //! biome's instance and free its memory.
            void unref(const Biome* biome);

            //! Unload everything and set all the refs to zero.
            void reset();

            //! Sets the biome manager to be locked, meaning that
            //! it will never unload data by unref.
            void setLocked(bool value) {
                _locked = value;
            }

            //! Refreshes the resident set and flushes any
            //! stale memory/textures.
            void flush();

        private:
            mutable Mutex _mutex;

            using BiomeRefs = std::map<const Biome*, int>;
            BiomeRefs _refs;
            //int _revision = 0;
            bool _locked = false;
            ModelAssetManager::Ptr _assetManager;

            // all model asset usage records, sorted by biome
            ResidentBiomesById _residentBiomes;

            //! Recalculate the required resident biome sets
            void recalculateResidentBiomes();

            //! Based on the computed set of resident biomes,
            //! loads any assets that need loading, making them resident.
            void materializeNewAssets(const osgDB::Options* readOptions);

        };
    }
} // namespace osgEarth::Procedural
