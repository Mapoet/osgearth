/* -*-c++-*- */
/* osgEarth - Geospatial SDK for OpenSceneGraph
* Copyright 2020 Pelican Mapping
* http://osgearth.org
*
* osgEarth is free software; you can redistribute it and/or modify
* it under the terms of the GNU Lesser General Public License as published by
* the Free Software Foundation; either version 2 of the License, or
* (at your option) any later version.
*
* This program is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU Lesser General Public License for more details.
*
* You should have received a copy of the GNU Lesser General Public License
* along with this program.  If not, see <http://www.gnu.org/licenses/>
*/
#pragma once

#include <osgEarthProcedural/Export>
#include <osgEarthProcedural/ModelAssetManager>
#include <osgEarth/Config>
#include <osgEarth/URI>
#include <osgEarth/Units>
#include <osgEarth/GeoData>
#include <osgEarth/LandCover>
#include <osgEarth/GLUtils>

namespace osgEarth
{
    namespace Procedural
    {
        using namespace osgEarth;

        /**
         * Holds a collection of asset traits, which can 
         * "filter" assets into particular biomes.
         */
        class OSGEARTHPROCEDURAL_EXPORT AssetTraits
        {
        public:
            static std::vector<std::string>
                getPermutationStrings(const std::vector<std::string>& traits);

            static std::vector<std::vector<std::string>>
                getPermutationVectors(const std::vector<std::string>& traits);

            static std::string
                toString(const std::vector<std::string>& traits);
        };

        /** 
         * Collection of artwork assets.
         * A biome may have a "parent" biome. This means that if the Biome
         * defines ZERO assets, it will use the parent biome's assets.
         */
        class OSGEARTHPROCEDURAL_EXPORT Biome
        {
        public:
            Biome();
            Biome(const Config& conf, AssetCatalog* assets);
            Config getConfig() const;

            //! Unique identifier of the biome
            OE_PROPERTY(std::string, id, {});

            //! Readable name/description of the biome
            OE_OPTION(std::string, name);

            //! Optional identifier of this biome's parent
            OE_OPTION(std::string, parentId);

            // A collection of asset pointers for each existing AssetGroup
            ModelAssetRefs _assetsToUse;

            //! Collection of this biome's asset pointers for the specified asset
            //! group, or the assets from the parent biome if this biome's asset
            //! list is empty.
            ModelAssetRefs getModelAssets(
                const std::string& group) const;

            //! Gets the collection of model assets associated with this biome
            //! irrespective of group
            const ModelAssetRefs& getModelAssets() const {
                return _assetsToUse;
            }

            //! The sequential biome index uses in encoded raster data
            //! Note: Starts at 1. Zero means "undefined."
            int index() const { return _index; }

            //! True is this biome contains no asset references
            bool empty() const;
            
        private:
            int _index;
            Biome* _parentBiome;
            bool _implicit; // whether this biome really exists or was derived by traits
            friend class BiomeCatalog;
        };

        /**
         * Defines all biomes, assets, and land use mappings used
         * by the procedural system.
         */
        class OSGEARTHPROCEDURAL_EXPORT BiomeCatalog
        {
        public:
            BiomeCatalog() { }
            BiomeCatalog(const Config& conf);

            //! Fetch a biome by its sequential index (as used in raster data)
            //! @return nullptr if no match
            const Biome* getBiomeByIndex(int index) const;

            //! Fetch a biome by its ID string
            const Biome* getBiome(const std::string& id) const;

            //! Vector of all biomes in the catalog
            std::vector<const Biome*> getBiomes() const;

            //! Asset catalog
            const AssetCatalog& getAssets() const;

        public:
            Config getConfig() const;

            Biome* getBiome(const std::string& id);

            int _biomeIndexGenerator;
            AssetCatalog _assets;

            std::map<int, Biome> _biomes_by_index; // keep ordered by index
            std::map<std::string, Biome*> _biomes_by_id; // keep ordered for determinism
        };

} } // namespace osgEarth::Procedural
